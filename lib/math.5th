: factorial ( x -- x! ) 2 swap inc range product ;

: prime? ( x -- prime-or-not ) -> x
    2 x sqrt ceil inc-range
    { x swap mod } map all
;

: gcd ( a b -- gcd(a,b) ) dup { tuck mod dup } while drop abs ;

: totient ( x -- phi(x) ) -> x
    1 x inc-range
    { x gcd 1 =? } map sum
;
