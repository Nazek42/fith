: -rot ( a b c -- c a b ) rot rot ;
: nip ( a b -- b ) swap drop ;
: tuck ( a b -- b a b ) swap over ;

: =? ( a b -- a=b ) cmp not ;
: >? ( a b -- a>b ) cmp 1 =? ;
: <? ( a b -- a<b ) cmp -1 =? ;
: >=? ( a b -- a>=b ) <? not ;
: <=? ( a b -- a<=b ) >? not ;
: !=? ( a b -- a!=b ) =? not ;

: >bool ( a -- bool ) not not ;

: 1+ ( x -- x+1 ) 1 + ;
: 1- ( x -- x-1 ) 1 - ;
: 2+ ( x -- x+2 ) 2 + ;
: 2- ( x -- x-2 ) 2 - ;

: map ( list transformation -- transformed-list )
    [ ] -> %mapresult%
    over len -> %length%
    0 -> %i%
    %i% %length% <? {
        over %i% @ over ~
        %mapresult% swap append drop
        %i% 1+ -> %i%
        %i% %length% <?
    } while
    drop drop %mapresult%
;

: for ( list block -- )
    over len -> %length%
    0 -> %i%
    %i% %length% <? {
        over %i% @ over ~
        %i% 1+ -> %i%
        %i% %length% <?
    } while
    drop drop
;

: dotimes ( func num -- )
    0 -> %i% -> %dotimes%
    -> %dtfunc%
    %i% %dotimes% <? {
        %dtfunc% ~
        %i% 1+ -> %i%
        %i% %dotimes% <?
    } while
;

: foldr ( [x1,x2,x3...xn] func -- folded )
    -> func
    dup len 1 - -> num
    dump func num dotimes
;

: filter ( list pred -- filtered )

;

: range ( a b -- [a,a+1...b-2,b-1] )
    -> %b% -> %a%
    [ ]
    %a% %b% <? {
        %a% append
        %a% 1+ -> %a%
        %a% %b% <?
    } while
;

: exc-range ( a b -- [a+1,a+2...b-2,b-1] ) swap 1+ swap range ;
: inc-range ( a b -- [a,a+1...b-1,b] ) 1+ range ;

: sum ( [x1,x2..xn] -- x1+x2+..+xn ) { + } foldr ;
: product ( [x1,x2..xn] -- x1*x2*..*xn ) { * } foldr ;

: []>bool ( [x1,x2..xn] -- [x1>bool,f2>bool..fn>bool] ) { >bool } map ;
: all ( [f1,f2..fn] -- f1&&f2&&..&&fn ) []>bool { and } foldr ;
: any ( [f1,f2..fn] -- f1||f2||..||fn ) []>bool { or } foldr ;

: prompt ( prompt-str -- input ) \. line ;
